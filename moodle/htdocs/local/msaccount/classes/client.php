<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Convenient wrappers and helper for using the msaccount API
 * @package    local_msaccount
 * @author Vinayak (Vin) Bhalerao (v-vibhal@microsoft.com)
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @copyright  Microsoft, Inc.
 */

namespace local_msaccount;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir.'/oauthlib.php');

/*
 * Subclass the oauth2_client class because we want to override some of its methods
 */
class client extends \oauth2_client {
    /** @var string OAuth 2.0 scope */
    const SCOPE = 'office.onenote_update wl.skydrive wl.offline_access';

    /** @var bool Whether to use the token as an HTTP GET parameter. */
    private $tokenasparam = true;

    /**
     * Construct a local_msaccount\client object.
     *
     * @param string $clientid client id for OAuth 2.0 provided by microsoft
     * @param string $clientsecret secret for OAuth 2.0 provided by microsoft
     * @param moodle_url $returnurl url to return to after succseful auth
     */
    public function __construct() {
        $returnurl = new \moodle_url('/local/msaccount/msaccount_redirect.php');
        $returnurl->param('sesskey', sesskey());

        parent::__construct(get_config('local_msaccount', 'clientid'), get_config('local_msaccount', 'clientsecret'),
                $returnurl, self::SCOPE);
    }

    /**
     * Determine if the msaccount client is configured.
     *
     * @return bool Whether the API client is configured.
     */
    public static function is_configured() {
        $clientid = get_config('local_msaccount', 'clientid');
        $clientsecret = get_config('local_msaccount', 'clientsecret');
        if (empty($clientid) || empty($clientsecret)) {
            return false;
        }
        return true;
    }

    /**
     * Returns the auth url for OAuth 2.0 request.
     *
     * @return string the auth url
     */
    protected function auth_url() {
        return 'https://login.live.com/oauth20_authorize.srf';
    }

    /**
     * Returns the token url for OAuth 2.0 request.
     *
     * @return string the auth url
     */
    protected function token_url() {
        return 'https://login.live.com/oauth20_token.srf';
    }

    /**
     * Check if user is logged in to Microsoft Account. Also called during OAuth authentication handshake to upgrade
     * the Oauth code to a token. Also handles expired tokens by getting a new token using the refresh token.
     * @return bool True iff the user is logged in.
     * @throws moodle_exception
     */
    public function is_logged_in() {
        $accesstoken = $this->get_accesstoken();

        // Has the token expired?
        if (isset($accesstoken->expires) && time() >= $accesstoken->expires) {
            if (!$this->refresh_token()) {
                $this->log_out();
                return false;
            }
        }

        // We have a token so we are logged in.
        if (isset($accesstoken->token)) {
            return true;
        }

        // If we've been passed then authorization code generated by the
        // authorization server try and upgrade the token to an access token.
        $code = optional_param('oauth2code', null, PARAM_RAW);
        if ($code && $this->upgrade_token($code)) {
            return true;
        }

        return false;
    }

    /**
     * Upgrade the oauth token during Oauth handshake during authentication.
     * @param $code OAuth code.
     * @return bool True iff successful in upgrading.
     * @throws moodle_exception
     */
    public function upgrade_token($code) {
        $callbackurl = self::callback_url();
        $params = array('client_id' => $this->get_clientid(),
            'client_secret' => $this->get_clientsecret(),
            'grant_type' => 'authorization_code',
            'code' => $code,
            'redirect_uri' => $callbackurl->out(false),
        );

        // Requests can either use http GET or POST.
        if ($this->use_http_get()) {
            $response = $this->get($this->token_url(), $params);
        } else {
            $response = $this->post($this->token_url(), $params);
        }

        if (!$this->info['http_code'] === 200) {
            throw new \moodle_exception('Could not upgrade oauth token');
        }

        $r = json_decode($response);

        if (!isset($r->access_token)) {
            return false;
        }

        // Store the token an expiry time.
        $accesstoken = new \stdClass;
        $accesstoken->token = $r->access_token;
        $accesstoken->expires = (time() + ($r->expires_in - 10)); // Expires 10 seconds before actual expiry.
        $this->store_token($accesstoken);

        $this->store_refresh_token($r->refresh_token);

        return true;
    }

    /**
     * Refresh the access token. Uses the refrehs token that was saved earlier. Also obtains and saves a new refresh
     * token for future use.
     * @return bool True iff successful.
     */
    public function refresh_token() {
        global $DB, $USER;

        $this->log_out(); // Remove previous token.

        $record = $DB->get_record('msaccount_refresh_tokens', array("user_id" => $USER->id));

        if (!$record || !$record->refresh_token) {
            return false;
        }

        $curl = new \curl();

        $curl->setHeader('Content-Type: application/x-www-form-urlencoded');

        $callbackurl = self::callback_url();

        $postdata = 'client_id=' . $this->get_clientid() .
            '&client_secret=' . $this->get_clientsecret() .
            '&grant_type=refresh_token' .
            '&refresh_token=' . $record->refresh_token .
            '&redirect_url=' . $callbackurl->out(false);

        $rawresponse = $curl->post($this->token_url(), $postdata, ['CURLOPT_HEADER' => 1]);

        if ($curl->errno != CURLE_OK) {
            return false;
        }

        $responsewithoutheader = substr($rawresponse, $curl->info['header_size']);
        $r = json_decode($responsewithoutheader);

        if (!isset($r->access_token)) {
            return false;
        }

        // Store the new token with new expiry time.
        $accesstoken = new \stdClass;
        $accesstoken->token = $r->access_token;
        $accesstoken->expires = (time() + ($r->expires_in - 10)); // Expires 10 seconds before actual expiry.
        $this->store_token($accesstoken);

        // Also update refresh token.
        $this->store_refresh_token($r->refresh_token);

        return true;
    }

    /**
     * Save refresh token into the database for future use.
     * @param $refreshtoken Refrehs token to be saved.
     */
    public function store_refresh_token($refreshtoken) {
        global $DB, $USER;

        $record = $DB->get_record('msaccount_refresh_tokens', array("user_id" => $USER->id));
        if ($record) {
            $record->refresh_token = $refreshtoken;
            $DB->update_record('msaccount_refresh_tokens', $record);
        } else {
            $record = new \stdClass();
            $record->user_id = $USER->id;
            $record->refresh_token = $refreshtoken;
            $DB->insert_record('msaccount_refresh_tokens', $record);
        }
    }

    /**
     * Should HTTP GET be used instead of POST?
     *
     * The Microsoft Account REST API requires an oauth token in the header for GET as well as POST requests.
     * The oauth2_client object we use to make these requests sets the token in the header only if it thinks that
     * it is making making a POST request. So we control that behavior by overriding this method and using the
     * "tokenasparam" field.
     *
     * @return bool true if GET should be used, otherwise use POST.
     */
    protected function use_http_get() {
        return $this->tokenasparam;
    }

    /**
     * Make HTTP GET call. Use this method instesad of the get() method because it handles the "token as param" issue
     * as well as retries in case of transient network errors.
     * @param $url Url to GET.
     * @param array $params Any parameters to be passed to the GET request.
     * @param string $token The Oauth token to be used to authenticate the request.
     * @param string $secret The secret to be used to authenticate the request.
     * @return mixed The HTTP response.
     */
    public function myget($url, $params=array(), $token='', $secret='') {
        $this->tokenasparam = false;
        $this->header = array();
        $response = $this->get($url, $params, $token, $secret);

        // If there is curl error due to connection. Try curl call for 3 times pausing for 0.5 sec.
        if (strpos($response, 'Could not resolve host') !== false || strpos($response, 'Failed to connect') !== false
            || strpos($response, 'Timed out') !== false) {
            for ($i = 0; $i < 3; $i++) {
                $response = $this->get($url, $params, $token, $secret);

                // If we get proper response, break the loop.
                if (strpos($response, 'Could not resolve host') === false || strpos($response, 'Failed to connect') === false
                    || strpos($response, 'Timed out') === false) {
                    break;
                }

                usleep(50000);
            }
        }

        $this->tokenasparam = true;
        return $response;
    }

    /**
     * Make HTTP POST call. Use this method instesad of the post() method because it handles the "token as param" issue
     * as well as retries in case of transient network errors.
     * @param $url Url to POST.
     * @param array $params Any parameters to be passed to the POST request.
     * @param string $token The Oauth token to be used to authenticate the request.
     * @param string $secret The secret to be used to authenticate the request.
     * @return mixed The HTTP response.
     */
    public function mypost($url, $params=array(), $token='', $secret='') {
        $this->tokenasparam = false;
        $this->setHeader('Content-Type: application/json');
        $response = $this->post($url, $params, $token, $secret);

        // If there is curl error due to connection. Try curl call for 3 times pausing for 0.5 sec.
        if (strpos($response, 'Could not resolve host') !== false || strpos($response, 'Failed to connect') !== false
            || strpos($response, 'Timed out') !== false) {
            for ($i = 0; $i < 3; $i++) {
                $response = $this->post($url, $params, $token, $secret);

                // If we get proper response, break the loop.
                if (strpos($response, 'Could not resolve host') === false || strpos($response, 'Failed to connect') === false
                    || strpos($response, 'Timed out') === false) {
                    break;
                }

                usleep(50000);
            }
        }

        $this->tokenasparam = true;
        return $response;
    }
}
